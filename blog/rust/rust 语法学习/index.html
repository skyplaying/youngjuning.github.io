<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta name="title" content="洛竹的官方网站" />
    <meta name="keywords" content="react, javascript, typescript" />
    <meta name="description" content="怕什么真理无穷，进一寸有一寸的欢喜" />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="https://i.loli.net/2021/01/07/LkH3VM6oBnIuFNi.png"
    />
    <link rel="stylesheet" href="/umi.26fedac2.css" />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.3.9
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.includes(e) ? e : r[0]
        );
      })();
    </script>
    <title>Rust 语法学习</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/blog/rust/rust 语法学习" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;https://i.loli.net/2021/01/07/LkH3VM6oBnIuFNi.png&#x27;)" href="/">洛竹的官方网站</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a aria-current="page" class="active" href="/blog">博客</a></span><span><a href="/awesome">收藏</a></span><span><a href="/about">关于</a></span><span><a href="/leetcode">算法</a></span><span><a href="/links">友链</a></span><span>洛竹文档⤵️<ul><li><a href="/cobra"> Cobra</a></li><li><a href="/viper"> Viper</a></li><li><a href="/github-actions"> GitHub Actions</a></li></ul></span><span><a target="_blank" rel="noopener noreferrer" href="https://juejin.cn/user/325111174662855/posts">掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span><span><a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/people/yangjunning">知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><ul><li><a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/column/c_1341734653628149760">前端早茶馆<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></span><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/youngjuning/youngjuning.github.io">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;https://i.loli.net/2021/01/07/LkH3VM6oBnIuFNi.png&#x27;)" href="/"></a><h1>洛竹的官方网站</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a aria-current="page" class="active" href="/blog">博客</a></li><li><a href="/awesome">收藏</a></li><li><a href="/about">关于</a></li><li><a href="/leetcode">算法</a></li><li><a href="/links">友链</a></li><li>洛竹文档⤵️<ul><li><a href="/cobra"> Cobra</a></li><li><a href="/viper"> Viper</a></li><li><a href="/github-actions"> GitHub Actions</a></li></ul></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.cn/user/325111174662855/posts">掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/people/yangjunning">知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><ul><li><a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/column/c_1341734653628149760">前端早茶馆<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/youngjuning/youngjuning.github.io">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/blog">Less is more</a></li><li><a href="/blog/deno">Deno</a><ul><li><a href="/blog/deno/deno git-hub action 源码解析"><span>Deno GitHub Action 源码解析</span></a></li><li><a href="/blog/deno/向 deno 学习脚本的管理"><span>向 Deno 学习脚本的管理</span></a></li></ul></li><li><a href="/blog/devops">Devops</a><ul><li><a href="/blog/devops/玩转 github actions"><span>玩转 GitHub Actions</span></a></li></ul></li><li><a href="/blog/go">Go</a><ul><li><a href="/blog/go/go语法学习笔记"><span>Go 语法学习笔记</span></a></li><li><a href="/blog/go/基于 go 实现 deno upgrade"><span>基于 Go 实现 Deno upgrade</span></a></li><li><a href="/blog/go/极速入门 go 并爬取掘金专栏"><span>极速入门 Go 并爬取掘金专栏</span></a></li></ul></li><li><a href="/blog/javascript">Javascript</a><ul><li><a href="/blog/javascript/使用jest和enzyme进行react native单元测试"><span>使用Jest和Enzyme进行React Native单元测试</span></a></li><li><a href="/blog/javascript/图解google-v8-学习笔记"><span>图解 Google V8 学习笔记</span></a></li></ul></li><li><a href="/blog/others">Others</a><ul><li><a href="/blog/others/程序员购钻指南"><span>程序员购钻指南：钻戒值不值得买？怎么买？</span></a></li></ul></li><li><a href="/blog/react-native">react-native</a><ul><li><a href="/blog/react-native/flutter-vs-react-native–what-to-choose-in-2021"><span>2021 Flutter 完胜 React Native ?</span></a></li><li><a href="/blog/react-native/react native 调试最佳实践"><span>React Native 调试最佳实践</span></a></li><li><a href="/blog/react-native/当我们在聊 rn 时，我们在谈什么"><span>当我们在聊 RN 时，我们在聊什么|技术点评</span></a></li><li><a href="/blog/react-native/给 react native 库添加 example"><span>给 React Native 库添加 Example</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/rust">Rust</a><ul><li><a href="/blog/rust/一个番茄钟入门 rust"><span>一个番茄钟入门 Rust</span></a></li><li><a aria-current="page" class="active" href="/blog/rust/rust 语法学习"><span>Rust 语法学习</span></a></li><li><a href="/blog/rust/rust 编写猜数游戏"><span>Rust 编写猜数游戏</span></a></li><li><a href="/blog/rust/为什么rust需要局部变量隐藏"><span>为什么 Rust 需要局部变量隐藏</span></a></li><li><a href="/blog/rust/rust 在 web 领域的应用"><span>Rust 在 Web 领域的应用</span></a></li></ul></li><li><a href="/blog/tools">Tools</a><ul><li><a href="/blog/tools/发布一个 homebrew 包"><span>发布一个 Homebrew 包</span></a></li><li><a href="/blog/tools/我的mac开发环境"><span>我的 Mac 开发环境</span></a></li></ul></li><li><a href="/blog/typescript">Typescript</a><ul><li><a href="/blog/typescript/向微软官方贡献 @types 包"><span>向微软官方贡献 @types 包</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="变量与可变性" data-depth="2"><a href="/blog/rust/rust 语法学习#变量与可变性"><span>变量与可变性</span></a></li><li title="常量与变量的不同" data-depth="2"><a href="/blog/rust/rust 语法学习#常量与变量的不同"><span>常量与变量的不同</span></a></li><li title="隐藏" data-depth="2"><a href="/blog/rust/rust 语法学习#隐藏"><span>隐藏</span></a></li><li title="数据类型" data-depth="2"><a href="/blog/rust/rust 语法学习#数据类型"><span>数据类型</span></a></li><li title="标量类型（scalar）" data-depth="3"><a href="/blog/rust/rust 语法学习#标量类型（scalar）"><span>标量类型（scalar）</span></a></li><li title="复合类型（compound）" data-depth="3"><a href="/blog/rust/rust 语法学习#复合类型（compound）"><span>复合类型（compound）</span></a></li><li title="函数（function）" data-depth="2"><a href="/blog/rust/rust 语法学习#函数（function）"><span>函数（function）</span></a></li><li title="函数参数" data-depth="3"><a href="/blog/rust/rust 语法学习#函数参数"><span>函数参数</span></a></li><li title="函数体中的语句和表达式" data-depth="3"><a href="/blog/rust/rust 语法学习#函数体中的语句和表达式"><span>函数体中的语句和表达式</span></a></li><li title="函数的返回值" data-depth="3"><a href="/blog/rust/rust 语法学习#函数的返回值"><span>函数的返回值</span></a></li><li title="控制流" data-depth="2"><a href="/blog/rust/rust 语法学习#控制流"><span>控制流</span></a></li><li title="if 表达式" data-depth="3"><a href="/blog/rust/rust 语法学习#if-表达式"><span>if 表达式</span></a></li><li title="使用循环重复执行代码" data-depth="2"><a href="/blog/rust/rust 语法学习#使用循环重复执行代码"><span>使用循环重复执行代码</span></a></li><li title="loop 循环" data-depth="3"><a href="/blog/rust/rust 语法学习#loop-循环"><span>loop 循环</span></a></li><li title="while 条件循环" data-depth="3"><a href="/blog/rust/rust 语法学习#while-条件循环"><span>while 条件循环</span></a></li><li title="使用 for 循环遍历集合" data-depth="3"><a href="/blog/rust/rust 语法学习#使用-for-循环遍历集合"><span>使用 for 循环遍历集合</span></a></li></ul><div class="__dumi-default-layout-content"><div style="display:flex;justify-content:center"><img src="https://i.loli.net/2021/02/13/xlQI48CR6LteNJV.png" width="70%"/></div><div class="markdown"><blockquote><p>本文部分示例代码在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/youngjuning/learn-rust">youngjuning/learn-rust<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，文章首发于 <a target="_blank" rel="noopener noreferrer" href="https://youngjuning.js.org/">洛竹的官方网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote><p>语言之间都有着类似的核心特性，比如变量、基本类型、函数、注释和控制流程等概念。但是每个语言有都有自己的独有概念，本文便是记录了我在学习 Rust 语法过程中遇到的 Rust 独有概念。</p><h2 id="变量与可变性"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#变量与可变性"><span class="icon icon-link"></span></a>变量与可变性</h2><p>Rust 中的变量默认是不可变的。Rust 语言提供这一概念是为了能够让你安全且方便地写出复杂、甚至是并行的代码。当然，Rust 也提供了让你可以使用可变变量的方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// main.rs</span></div><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let x = 5;</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of x is: {}&quot;, x);</span></div><div class="token-line"><span class="token plain">  x = 6;</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of x is: {}&quot;, x)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p><code>x = 6</code> 属于重复赋值，所以执行 <code>cargo run</code> 编译是不会通过的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c69b2d8dd78470d917c730a5fe5a0d0~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfbdcb5c80944149b31b331b8165aee~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><p>我们可以通过在声明的变量名称前添加 <code>mut</code> 关键字来使其可变。除了使变量的值可变，<code>mut</code> 还会向阅读代码的人暗示其他代码可能会改变这个变量的值。</p><h2 id="常量与变量的不同"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#常量与变量的不同"><span class="icon icon-link"></span></a>常量与变量的不同</h2><ol><li>我们不能使用 <code>mut</code> 关键字来修饰一个变量。常量不仅是默认不可变的，它还总是不可变的。</li><li>你需要使用 <code>const</code> 关键字而不是一个 <code>let</code> 关键字来声明一个常量。</li><li>在声明的同时，你必须显式地标注值的类型。</li><li>常量可以被声明在任何作用域中，甚至包括全局作用域。这在一个值需要被不同部分的代码共同引用时十分有用</li><li>你只能将一个常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。</li></ol><blockquote><p>我们约定俗称地使用以下划线分割的全大写字母来命名一个常量，并在数值中插入下划线来提高可读性：<code>const MAX_POINTS: u32 = 100_000;</code></p></blockquote><h2 id="隐藏"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#隐藏"><span class="icon icon-link"></span></a>隐藏</h2><p>在 Rust 中，新声明的变量可以覆盖掉旧的同名变量，我们把这一现象描述为：第一个变量被第二个变量隐藏（shadow）了。这意味着我们随后使用这个名称时，它指向的将会是第二个变量。我们可以重复使用 <code>let</code> 关键字并分配以相同的名称来不断地隐藏变量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">    let x = 5;</span></div><div class="token-line"><span class="token plain">    let x = x + 1;</span></div><div class="token-line"><span class="token plain">    let x = x * 2;</span></div><div class="token-line"><span class="token plain">    println!(&quot;The value of x is: {}&quot;, x)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>如下图，我们可以看到 JavaScript 中并没有该特性：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b566023d5f486996638d08cdbf31b3~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><p>隐藏机制和变量声明为 <code>mut</code> 的不同：</p><ol><li>如果不是在使用 <code>let</code> 重新为这个变量赋值，则会导致编译错误。通过使用 <code>let</code>，我们可以对这个值执行一系列的变换操作，并允许这个变量在操作完成后保持自己的不可变性。</li><li>由于重复使用 <code>let</code> 关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。</li></ol><h2 id="数据类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#数据类型"><span class="icon icon-link"></span></a>数据类型</h2><p><img src="https://i.loli.net/2021/02/21/7I2DhsMqAUbxBa8.png" alt=""/></p><p>RUST 的编译器可以根据我们如何绑定、使用变量的值来自动推导出变量的类型。但在无法自动推导的场景，就必须显式地添加一个类型标注。</p><h3 id="标量类型（scalar）"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#标量类型（scalar）"><span class="icon icon-link"></span></a>标量类型（scalar）</h3><p><strong>标量</strong>类型是单个值类型的统称。Rust 中内建了 4 种基础的标量类型：整数、浮点数、布尔值及字符。这类似于 JavaScript 中的基础类型。</p><h4 id="整数类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#整数类型"><span class="icon icon-link"></span></a>整数类型</h4><p>整数是指那些没有小数部分的数字。</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bit</td><td>i8（-128 到 127）</td><td>u8（0 到 255）</td></tr><tr><td>16 bit</td><td>i16（-32768 到 32767）</td><td>u16（0 到 65535）</td></tr><tr><td>32 bit</td><td>i32(默认)</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><blockquote><p>Isize 和 usize 是特殊的整数类型，它们的长度取决于程序运行的目标平台。在 64 位架构上，它们就是 64 位的，而在 32 位架构上，它们就是 32 位的。</p></blockquote><blockquote><p>可以使用 <code>_</code> 作为分隔符以方便读数，比如 <code>1_000</code></p></blockquote><p>如何选择：</p><ul><li>如果拿不定注意，Rust 对于整数字面量默认推导类型 i32 通常就是一个很好的选择：它在大部分情况下都是运算速度最快的</li><li>较为特殊的两个整数类型 <code>usize</code> 和 <code>isize</code> 则主要用作某些集合的索引</li></ul><h4 id="浮点数类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#浮点数类型"><span class="icon icon-link"></span></a>浮点数类型</h4><ul><li>单精度浮点数（<code>f32</code>）</li><li>双精度浮点数（<code>f64</code>）(默认)</li></ul><blockquote><p>由于在现代 CPU 中双精度和单精度的运行效率相差无几，却拥有更高的精读，所以在 Rust 中，默认会将浮点数字面量的类型推到为 f64。</p></blockquote><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let x = 2.0; // f64</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  let y: f32 = 3.0; // f32</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><h4 id="布尔值"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#布尔值"><span class="icon icon-link"></span></a>布尔值</h4><p>和 Go 语言一样，Rust 的布尔类型只拥有两个可能的值：<code>true</code>和 <code>false</code>。相较于 Javascript 中<code>false</code>、<code>0</code>、 <code>NaN</code>、<code>&#x27;&#x27;</code>、<code>null</code>、<code>undefined</code> 6 种都可以被转换成 <code>false</code> 真的是很节省脑容量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let t = true;</span></div><div class="token-line"><span class="token plain">  let f: bool = false // 附带了显式类型标注的语句</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><h4 id="字符类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#字符类型"><span class="icon icon-link"></span></a>字符类型</h4><p>在 Rust 中，<code>char</code> 类型被用于描述语言中最基础的单个字符。需要注意的是，<code>char</code> 类型使用单引号指定，而不同于字符串使用双引号指定。</p><h3 id="复合类型（compound）"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#复合类型（compound）"><span class="icon icon-link"></span></a>复合类型（compound）</h3><p>复合类型可以将多个不同类型的值组合为一个类型。Rust 提供了两种内置的基础复合类型：元组（tuple）和数组（array）。</p><h4 id="元组类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#元组类型"><span class="icon icon-link"></span></a>元组类型</h4><ul><li>元组可以将其他不同类型的多个值进行组合</li><li>元组拥有一个固定的长度，我们无法在声明结束后增加或减少其中的元素数量</li></ul><p><strong>创建元组：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">    let tup: (i32, f64, u8) = (500, 6.4, 1);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><ul><li>把一些列值使用逗号分隔后放置到一对圆括号中</li><li>元组每个位置的值都有一个类型，这些类型不需要是相同的。</li></ul><p>上面这段带来执行 <code>cargo run</code> 会有编译警告：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3db475c146fa43aabef6a2be17dbe1b4~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><p>意思是，如果你是故意声明一个 <code>unused variable</code>，那就给变量名加一个下划线前缀来忽略警告</p><p><strong>取值：</strong></p><p>1、解构（destructuring）：使用模式匹配来解构元组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">    let tup = (500, 6.4, 1);</span></div><div class="token-line"><span class="token plain">    let (_x, y, _z) = tup;</span></div><div class="token-line"><span class="token plain">    println!(&quot;The value of y is: {}&quot;, y);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>2、通过索引并使用点号(<code>.</code>)来访问元组中的值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let x: (i32, f64, u8) = (500, 6.4, 1);</span></div><div class="token-line"><span class="token plain">  let five_hundred = x.0;</span></div><div class="token-line"><span class="token plain">  let six_point_four = x.1;</span></div><div class="token-line"><span class="token plain">  let one = x.2;</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><h4 id="数组类型"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#数组类型"><span class="icon icon-link"></span></a>数组类型</h4><h5 id="数组（array）"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#数组（array）"><span class="icon icon-link"></span></a>数组（array）</h5><p>通常当你不想在栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具。</p><ul><li>与元组不同的是数组中的每一个元素都必须是相同的类型。</li><li>Rust 中的数组拥有固定的长度，一旦声明就再也不能随意更改大小，这与其他语言不同。</li></ul><p>在 Rust 中，你可以将以逗号分隔的值放置在一对方括号内来创建一个数组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let a = [1, 2, 3, 4, 5]</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>为了写出数组的类型，你需要使用一对方括号，并在方括号中填写数组内所有元素的类型、一个分号以及数组内元素的数量，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let a: [i32, 5] = [1, 2, 3, 4, 5]</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p><strong>创建一个含有相同元素的数组：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let a = [3; 5]</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>以 <code>a</code> 命名的数组将会拥有 5 个元素，而这些元素全部拥有相同的初始值 3。这一写法等价于 <code>let a = [3, 3, 3, 3, 3]</code>。</p><p><strong>访问数组的元素：</strong></p><p>数组由一整块分配在栈上的内存组成，你可以通过索引来访问一个数组中的所有元素：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">	let a = [1, 2, 3, 4, 5];</span></div><div class="token-line"><span class="token plain">  let first = a[0];</span></div><div class="token-line"><span class="token plain">  let second = a[1];</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p><strong>非法的数组访问</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let a = [1, 2, 3, 4, 5];</span></div><div class="token-line"><span class="token plain">  let index = 10;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  let element = a[index];</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of elements is: {}&quot;, element)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>在 <a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/">Rust Playground<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 运行这段代码，编译器提示我们，这个操作将会在运行时崩溃。原因是索引越界（Java 常见错误），数组长度是 5，但是我们给的索引是 10。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af82e05277824ab285e1c35224c07996~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><blockquote><p>许多底层语言并没有类似的检查，一旦尝试使用非法索引，你就会访问到某块无效的内存空间（JavaScript 中则返回一个 <code>undefined</code>）</p></blockquote><h5 id="动态数组（vector）"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#动态数组（vector）"><span class="icon icon-link"></span></a>动态数组（vector）</h5><p>动态数组是一个类似于数组的集合结构，但它允许用户自由地调整数组长度。如果你不确定使用数组还是动态数组，那就先使用动态数组吧。动态数组属于高级语法，不在本文讨论范围，后期会出一期更深入的解析。</p><h2 id="函数（function）"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#函数（function）"><span class="icon icon-link"></span></a>函数（function）</h2><ul><li><code>main</code> 函数是大部分程序开始的地方。</li><li>使用 <code>fn</code> 关键字来声明一个新的函数。</li><li>Rust 代码使用**蛇形命名法（snake case）**来作为规范函数和变量名称的风格。蛇形命名法只使用小写的字母进行命名，并以下划线分隔单词。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main () {</span></div><div class="token-line"><span class="token plain">    println!(&quot;Hello world!&quot;);</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    another_function();</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn another_function() {</span></div><div class="token-line"><span class="token plain">    println!(&quot;Another function&quot;);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><h3 id="函数参数"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#函数参数"><span class="icon icon-link"></span></a>函数参数</h3><p>函数参数是一种特殊的变量，并被视作函数签名的一部分。当函数存在参数时，你需要在调用函数时为这些变量提供具体的值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  another_function(5);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn another_function(x: i32) {</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of x is: {}&quot;, x)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><blockquote><p>和 Go 语言一样，在 Rust 函数签名中，你必须显式地声明每个参数的类型。</p></blockquote><p>和其他编程语言一样，Rust 中也是使用 <code>,</code> 来分隔多个参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  another_function(5, 6);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn another_function(x: i32, y: i32) {</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of x is: {}&quot;, x);</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of y is: {}&quot;, y);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><h3 id="函数体中的语句和表达式"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#函数体中的语句和表达式"><span class="icon icon-link"></span></a>函数体中的语句和表达式</h3><p>由于 Rust 是一门基于表达式的语言，所以它将语句（statement）与表达式（expression）区别为两个不同的概念。语句指那些执行操作但不返回值的指令，而表达式则是指会进行计算并产生一个值作为结果的指令。这个其他语言不太一样：</p><p>在 C 语言、Ruby、JavaScript 中 <code>var x = y = 6</code> 这种赋值语句会返回所赋的值，但是 Rust 中是行不通的。</p><p>值得注意的是，下面代码中的 <code>x+1</code> 是表达式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let x = 5;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  let y = {</span></div><div class="token-line"><span class="token plain">    let x = 3;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    x + 1</span></div><div class="token-line"><span class="token plain">  }</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of y is: {}&quot;, y);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>但是如果我们在表达式末尾加上了分号，这一段代码就变成了语句而不会返回任何值。</p><h3 id="函数的返回值"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#函数的返回值"><span class="icon icon-link"></span></a>函数的返回值</h3><ul><li>在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。</li><li>和其他编程语言不同的是，Rust 中函数的 <code>return</code> 语句不是必需的，只是一个用来提前返回的关键字。而且大多数函数都隐式地返回了最后的表达式。</li><li>需要在瘦箭头（<code>-&gt;</code>）的后面声明它的类型。</li></ul><p>函数体最后一行必须是表达式，不要加分号，下面是反例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let x = plus_one(5);</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of x is: {}&quot;, x);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn plus_one(x: i32) -&gt; i32 {</span></div><div class="token-line"><span class="token plain">  x + 1;</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>尝试编译这段代码会产生如下错误信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a309eddc6244e4a5b45bcd39553156~tplv-k3u1fbpfcp-zoom-1.image" alt=""/></p><p>可以看出，由于 <code>x +1;</code> 是表达式没有返回值，函数体隐式地返回了空元祖（<code>()</code>），进而导致编译时 <code>mismatched types</code> 错误。编译器给的建议是删除 <code>x +1;</code> 语句的分号。</p><h2 id="控制流"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#控制流"><span class="icon icon-link"></span></a>控制流</h2><h3 id="if-表达式"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#if-表达式"><span class="icon icon-link"></span></a>if 表达式</h3><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">    let number = 3;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    if number &lt; 5 {</span></div><div class="token-line"><span class="token plain">        println!(&quot;condition was true&quot;);</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        println!(&quot;condition was false&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><ul><li>和 Go 一样，判断条件不需要圆括号包裹。</li><li>代码中的条件表达式必须产生一个 <code>bool</code> 类型的值，否则就会触发编译错误。</li><li>与 Ruby 或 JavaScript 等语言不同，Rust 没有隐式转换</li></ul><h4 id="在-let-语句中使用-if"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#在-let-语句中使用-if"><span class="icon icon-link"></span></a>在 <code>let</code> 语句中使用 <code>if</code></h4><p>由于<code>if</code> 是一个表达式，所以我们可以再 <code>let</code> 语句的右侧使用它来生成一个值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let condition = true;</span></div><div class="token-line"><span class="token plain">  let number = if condition {</span></div><div class="token-line"><span class="token plain">    5</span></div><div class="token-line"><span class="token plain">  } else {</span></div><div class="token-line"><span class="token plain">    6</span></div><div class="token-line"><span class="token plain">  };</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  println!(&quot;The value of number is: {}&quot;, number);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><ul><li>代码块输出的值就是其中最后一个表达式的值，另外，数字本身也可以作为一个表达式使用。</li><li>整个 <code>if</code> 表达式的值取决于究竟是哪一个代码块得到了执行。这意味着，所有 <code>if</code> 分支可能返回的值都必须是一种类型的。</li></ul><h2 id="使用循环重复执行代码"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#使用循环重复执行代码"><span class="icon icon-link"></span></a>使用循环重复执行代码</h2><p>Rust 提供了 3 种循环：<code>loop</code>、<code>while</code>和<code>for</code></p><h3 id="loop-循环"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#loop-循环"><span class="icon icon-link"></span></a>loop 循环</h3><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  loop {</span></div><div class="token-line"><span class="token plain">    println!(&quot;again!&quot;)</span></div><div class="token-line"><span class="token plain">  }</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>运行这段程序时，除非我们手动强制退出程序，否则 <code>again!</code> 会被反复地输出到屏幕上。</p><p><strong>从 loop 循环中返回值</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let mut counter = 0;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  let result = loop {</span></div><div class="token-line"><span class="token plain">    counter += 1;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    if counter == 10 {</span></div><div class="token-line"><span class="token plain">      break counter * 2</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">  };</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  println!(&quot;The result is {}&quot;, result);</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>上面的代码中我们将需要返回的值添加到 break 表达式后面，也就是我们用来终止循环的表达式后面。</p><h3 id="while-条件循环"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#while-条件循环"><span class="icon icon-link"></span></a>while 条件循环</h3><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let mut number = 3;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  while number !=0 {</span></div><div class="token-line"><span class="token plain">    println!(&quot;{}!&quot;, number);</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    number = number - 1;</span></div><div class="token-line"><span class="token plain">  }</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  println!(&quot;LOFTOFF!!!&quot;)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p><code>while</code> 循环的模式是会在每次执行循环体之前都判断一次条件，假如条件为真则执行代码片段，加入条件为假或在执行过程中碰到 <code>break</code> 就退出当前循环。这种模式可以通过 <code>loop</code>、<code>if</code>、<code>else</code> 及 <code>break</code> 关键字的组合使用来实现。</p><h3 id="使用-for-循环遍历集合"><a aria-hidden="true" tabindex="-1" href="/blog/rust/rust 语法学习#使用-for-循环遍历集合"><span class="icon icon-link"></span></a>使用 for 循环遍历集合</h3><p>我们可以使用 <code>for</code> 循环来遍历集合中的每一个元素。</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  let a = [10, 20, 30, 40, 50];</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">  for element in a.iter() {</span></div><div class="token-line"><span class="token plain">    println!(&quot;The value is: {}&quot;, element)</span></div><div class="token-line"><span class="token plain">  }</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p><code>for</code> 循环的安全性和简捷性使它成为了 Rust 中最为常用的循环结构。大部分的 Rust 开发者也会选择使用 for 循环。</p><p>下面的例子中，我们配合标准库中的 Range 来实现打印 <code>1</code> 到<code>4</code>:</p><div class="__dumi-default-code-block"><pre class="prism-code language-rust"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">  for number in (1..4).rev() {</span></div><div class="token-line"><span class="token plain">    println!(&quot;{}!&quot;, number);</span></div><div class="token-line"><span class="token plain">  }</span></div><div class="token-line"><span class="token plain">  println!(&quot;LIFTOFF!!!&quot;)</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div></pre></div><p>寻了一圈，未得一个 Rust 交流群，自己组了一个，欢迎大佬加入：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c2c082db1d4cd4b4b3d183be97968b~tplv-k3u1fbpfcp-watermark.image" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/youngjuning/youngjuning.github.io/edit/main/docs/blog/rust/Rust 语法学习.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">3/8/2021 06:14:52</span></div></div><div class="ant-back-top"></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/umi.f562df49.js"></script>
  </body>
</html>
