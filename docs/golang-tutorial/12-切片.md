---
title: 切片
cover: https://i.loli.net/2021/04/03/IwE7y9VDotP3igd.png
tags: [掘金专栏]
order: 12
---

> 大家好，我是 [@洛竹](https://github.com/youngjuning)
>
> 本文首发于 [洛竹的官方网站](https://youngjuning.js.org/)
>
> 本文同步于公众号『洛竹早茶馆』，转载请联系作者。
>
> 创作不易，养成习惯，素质三连！

A slice is a convenient, flexible and powerful wrapper on top of an array. Slices do not own any data on their own. They are just references to existing arrays.

## Creating a slice

A slice with elements of type T is represented by `[]T`

```go
package main

import (
    "fmt"
)

func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4] //creates a slice from a[1] to a[3]
    fmt.Println(b)
}
```

[Run in playground](https://play.golang.org/p/Za6w5eubBB)

The syntax `a[start:end]` creates a slice from array `a` starting from index `start` to index `end \- 1`. So in line no. 9 of the above program `a[1:4]` creates a slice representation of the array `a` starting from indexes 1 through 3. Hence the slice `b` has values `[77 78 79]`.

Let's look at another way to create a slice.

```go
package main

import (
    "fmt"
)

func main() {
    c := []int{6, 7, 8} //creates and array and returns a slice reference
    fmt.Println(c)
}
```

[Run in playground](https://play.golang.org/p/_Z97MgXavA)

In the above program in line no. 9, `c := []int{6, 7, 8}` creates an array with 3 integers and returns a slice reference which is stored in c.

### modifying a slice

A slice does not own any data of its own. It is just a representation of the underlying array. Any modifications done to the slice will be reflected in the underlying array.

```go
package main

import (
    "fmt"
)

func main() {
    darr := [...]int{57, 89, 90, 82, 100, 78, 67, 69, 59}
    dslice := darr[2:5]
    fmt.Println("array before",darr)
    for i := range dslice {
        dslice[i]++
    }
    fmt.Println("array after",darr)
}
```

[Run in playground](<https://play.golang.org/p/6FinudNf1k >)

In line number 9 of the above program, we create `dslice` from indexes 2, 3, 4 of the array. The for loop increments the value in these indexes by one. When we print the array after the for loop, we can see that the changes to the slice are reflected in the array. The output of the program is

```
array before [57 89 90 82 100 78 67 69 59]
array after [57 89 91 83 101 78 67 69 59]
```

When a number of slices share the same underlying array, the changes that each one makes will be reflected in the array.

```go
package main

import (
    "fmt"
)

func main() {
    numa := [3]int{78, 79 ,80}
    nums1 := numa[:] //creates a slice which contains all elements of the array
    nums2 := numa[:]
    fmt.Println("array before change 1",numa)
    nums1[0] = 100
    fmt.Println("array after modification to slice nums1", numa)
    nums2[1] = 101
    fmt.Println("array after modification to slice nums2", numa)
}
```

[Run in playground](https://play.golang.org/p/mdNi4cs854)

In line no. 9, in `numa[:]` the start and end values are missing. The default values for start and end are `0` and `len(numa)` respectively. Both slices `nums1` and `nums2` share the same array. The output of the program is

```
array before change 1 [78 79 80]
array after modification to slice nums1 [100 79 80]
array after modification to slice nums2 [100 101 80]
```

From the output, it's clear that when slices share the same array. The modifications made to the slice are reflected in the array.

### length and capacity of a slice

The length of the slice is the number of elements in the slice. **The capacity of the slice is the number of elements in the underlying array starting from the index from which the slice is created.**

Let's write some code to understand this better.

```go
package main

import (
    "fmt"
)

func main() {
    fruitarray := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
    fruitslice := fruitarray[1:3]
    fmt.Printf("length of slice %d capacity %d", len(fruitslice), cap(fruitslice)) //length of fruitslice is 2 and capacity is 6
}
```

[Run in playground](https://play.golang.org/p/a1WOcdv827)

In the above program, `fruitslice` is created from indexes 1 and 2 of the `fruitarray`. Hence the length of `fruitslice` is 2.

The length of the `fruitarray` is 7. `fruiteslice` is created from index `1` of `fruitarray`. Hence the capacity of `fruitslice` is the no of elements in `fruitarray` starting from index `1` i.e from `orange` and that value is `6`. Hence the capacity of `fruitslice` is 6. The [program](https://play.golang.org/p/a1WOcdv827) prints **length of slice 2 capacity 6**.

A slice can be re-sliced upto its capacity. Anything beyond that will cause the program to throw a run time error.

```go
package main

import (
    "fmt"
)

func main() {
    fruitarray := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
    fruitslice := fruitarray[1:3]
    fmt.Printf("length of slice %d capacity %d\n", len(fruitslice), cap(fruitslice)) //length of is 2 and capacity is 6
    fruitslice = fruitslice[:cap(fruitslice)] //re-slicing furitslice till its capacity
    fmt.Println("After re-slicing length is",len(fruitslice), "and capacity is",cap(fruitslice))
}
```

[Run in playground](<https://play.golang.org/p/GcNzOOGicu >)

In line no. 11 of the above program,`fruitslice` is re-sliced to its capacity. The above program outputs,

```
length of slice 2 capacity 6
After re-slicing length is 6 and capacity is 6
```

### creating a slice using make

_func make\(\[\]T, len, cap\) \[\]T_ can be used to create a slice by passing the type, length and capacity. The capacity parameter is optional and defaults to the length. The make function creates an array and returns a slice reference to it.

```go
package main

import (
    "fmt"
)

func main() {
    i := make([]int, 5, 5)
    fmt.Println(i)
}
```

[Run in playground](https://play.golang.org/p/M4OqxzerxN)

The values are zeroed by default when a slice is created using make. The above program will output `[0 0 0 0 0]`.

## Appending to a slice

As we already know arrays are restricted to fixed length and their length cannot be increased. Slices are dynamic and new elements can be appended to the slice using `append` function. The definition of append function is `func append(s []T, x ...T) []T`.

**x ...T** in the function definition means that the function accepts variable number of arguments for the parameter x. These type of functions are called [variadic functions](https://golangbot.com/variadic-functions/).

One question might be bothering you though. If slices are backed by arrays and arrays themselves are of fixed length then how come a slice is of dynamic length. Well what happens under the hood is, when new elements are appended to the slice, a new array is created. The elements of the existing array are copied to this new array and a new slice reference for this new array is returned. The capacity of the new slice is now twice that of the old slice. Pretty cool right :\). The following program will make things clear.

```go
package main

import (
    "fmt"
)

func main() {
    cars := []string{"Ferrari", "Honda", "Ford"}
    fmt.Println("cars:", cars, "has old length", len(cars), "and capacity", cap(cars)) //capacity of cars is 3
    cars = append(cars, "Toyota")
    fmt.Println("cars:", cars, "has new length", len(cars), "and capacity", cap(cars)) //capacity of cars is doubled to 6
}
```

[Run in playground](https://play.golang.org/p/VUSXCOs1CF)

In the above program, the capacity of `cars` is 3 initially. We append a new element to cars in line no. 10 and assign the slice returned by `append(cars, "Toyota")` to cars again. Now the capacity of cars is doubled and becomes 6. The output of the above program is

```
cars: [Ferrari Honda Ford] has old length 3 and capacity 3
cars: [Ferrari Honda Ford Toyota] has new length 4 and capacity 6
```

The zero value of a slice type is `nil`. A `nil` slice has length and capacity 0. It is possible to append values to a `nil` slice using the append function.

```go
package main

import (
    "fmt"
)

func main() {
    var names []string //zero value of a slice is nil
    if names == nil {
        fmt.Println("slice is nil going to append")
        names = append(names, "John", "Sebastian", "Vinay")
        fmt.Println("names contents:",names)
    }
}
```

[Run in playground](https://play.golang.org/p/x_-4XAJHbM)

In the above program `names` is nil and we have appended 3 strings to `names`. The output of the program is

```
slice is nil going to append
names contents: [John Sebastian Vinay]
```

It is also possible to append one slice to another using the `...` operator. You can learn more about this operator in the [variadic functions](https://golangbot.com/variadic-functions/) tutorial.

```go
package main

import (
    "fmt"
)

func main() {
    veggies := []string{"potatoes","tomatoes","brinjal"}
    fruits := []string{"oranges","apples"}
    food := append(veggies, fruits...)
    fmt.Println("food:",food)
}
```

[Run in playground](https://play.golang.org/p/UnHOH_u6HS)

In line no. 10 of the above program _food_ is created by appending `fruits` to `veggies`. Output of the program is `food: [potatoes tomatoes brinjal oranges apples]`

### Passing a slice to a function

Slices can be thought of as being represented internally by a structure type. This is how it looks,

```
type slice struct {
    Length        int
    Capacity      int
    ZerothElement *byte
}
```

A slice contains the length, capacity and a pointer to the zeroth element of the array. When a slice is passed to a function, even though it's passed by value, the pointer variable will refer to the same underlying array. Hence when a slice is passed to a function as parameter, changes made inside the function are visible outside the function too. Lets write a program to check this out.

```go
package main

import (
    "fmt"
)

func subtactOne(numbers []int) {
    for i := range numbers {
        numbers[i] -= 2
    }

}
func main() {
    nos := []int{8, 7, 6}
    fmt.Println("slice before function call", nos)
    subtactOne(nos)                               //function modifies the slice
    fmt.Println("slice after function call", nos) //modifications are visible outside
}
```

[Run in playground](<https://play.golang.org/p/IzqDihNifq >)

The function call in line number 17 of the above program decrements each element of the slice by 2. When the slice is printed after the function call, these changes are visible. If you can recall, this is different from an array where the changes made to an array inside a function are not visible outside the function. Output of the above [program](<https://play.golang.org/p/bWUb6R-1bS >) is,

```
slice before function call [8 7 6]
slice after function call [6 5 4]
```

### Multidimensional slices

Similar to arrays, slices can have multiple dimensions.

```go
package main

import (
    "fmt"
)

func main() {
     pls := [][]string {
            {"C", "C++"},
            {"JavaScript"},
            {"Go", "Rust"},
            }
    for _, v1 := range pls {
        for _, v2 := range v1 {
            fmt.Printf("%s ", v2)
        }
        fmt.Printf("\n")
    }
}
```

[Run in playground](https://play.golang.org/p/--p1AvNGwN)

The output of the program is,

```
C C++
JavaScript
Go Rust
```

### Memory Optimisation

Slices hold a reference to the underlying array. As long as the slice is in memory, the array cannot be garbage collected. This might be of concern when it comes to memory management. Lets assume that we have a very large array and we are interested in processing only a small part of it. Henceforth we create a slice from that array and start processing the slice. The important thing to be noted here is that the array will still be in memory since the slice references it.

One way to solve this problem is to use the [copy](https://golang.org/pkg/builtin/#copy) function `func copy(dst, src []T) int` to make a copy of that slice. This way we can use the new slice and the original array can be garbage collected.

```go
package main

import (
    "fmt"
)

func countries() []string {
    countries := []string{"USA", "Singapore", "Germany", "India", "Australia"}
    neededCountries := countries[:len(countries)-2]
    countriesCpy := make([]string, len(neededCountries))
    copy(countriesCpy, neededCountries) //copies neededCountries to countriesCpy
    return countriesCpy
}
func main() {
    countriesNeeded := countries()
    fmt.Println(countriesNeeded)
}
```

[Run in playground](https://play.golang.org/p/35ayYBhcDE)

In line no. 9 of the above program, `neededCountries := countries[:len(countries)-2]` creates a slice of `countries` barring the last 2 elements. Line no. 11 of the above program copies `neededCountries` to `countriesCpy` and also returns it from the function in the next line. Now `countries` array can be garbage collected since `neededCountries` is no longer referenced.

I have compiled all the concepts we discussed so far into a single program. You can download it from [github](https://github.com/golangbot/arraysandslices).

Thats it for arrays and slices. Thanks for reading. Please leave your valuable feedback and comments.

## 结语

关注公众号`洛竹早茶馆`，一个持续分享编程知识的地方。

- `点赞`等于学会，`在看`等于精通
- 最后祝大家 2021 学习进步，升职加薪

![](https://youngjuning.js.org/img/luozhu.png)
